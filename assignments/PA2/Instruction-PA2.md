# Instruction of PA2

## Preparation

- Read `The Cool Reference Manual`, `Flex Manual` and `README`.
- Read `cool-parse.h`，`stringtab.h`，`stringtab_functions.h`.
- Read `examples/manual` in Flex Project.
- Download correct version of [`Flex v2.5.35`](https://launchpad.net/ubuntu/+source/flex/2.5.35-10ubuntu3).

## The lexical structure of Cool

- **Integers**
- **Type indentifiers** and **Object Indentifiers**
- **Spcical Notation** (e.g. parentheses, assignment operator, etc.)
- **Strings**
- **Keywords**
- **White space**
- **Comments**

### Strings

A string may not contain:

1. non-escaped newline character
2. EOF
3. contain the null (character \0)

### Commments


## Important Points of PA2

### In `cool-parse.h`: 

- Your implementation needs to define Flex rules that match the regular expressions defining each token defined in `cool-parse.h` and perform the appropriate action for each matched token. 
- For example, if you match on a token `BOOL_CONST`, your lexer has to record whether its value is true or false; similarly if you match on a `TYPEID` token, you need to record the name of the type. 
- Note that not every token requires storing additional information; for example, only returning the token type is sufficient for some tokens like **keywords**.
- Your scanner should be robust—it should work for any conceivable input. For example, you must handle errors such as an `EOF` occurring in the middle of a string or comment, as well as string constants that are too long. These are just some of the errors that can occur; see the manual for the rest.

### Error Handling:

- All errors should be passed along to the parser. **Your lexer should not print anything**. Errors are communicated to the **parser** by returning a special error token called `ERROR`. (Note, you should ignore the token called `error` [in lowercase] for this assignment; it is used by the parser in **PA3**.)
- When an invalid character (one that can’t begin any token) is encountered, a string containing just that character should be returned as the error string. Resume lexing at the following character.
- If a string contains an **unescaped newline**, report that error as "Unterminated string constant" and resume lexing at the beginning of the next line—we assume the programmer simply forgot the close-quote.
- When a string is too long, report the error as "String constant too long" in the error string in the `ERROR` token. If the string contains invalid characters (i.e., the null character), report this as "String contains null character". In either case, **lexing should resume after the end of the string**. The end of the string is defined as either
  1. the beginning of the next line if an unescaped newline occurs after these errors are encountered
  2. after the closing " otherwise.
- If a comment remains open when EOF is encountered, report this error with the message "EOF in comment". Do not tokenize the comment’s contents simply because the terminator is missing. Similarly for strings, if an EOF is encountered before the close-quote, report this error as "EOF in string constant".
- If you see `*)` outside a comment, report this error as "Unmatched *)", rather than tokenizing it as `*` and `)`.

### String Table

Programs tend to have many occurrences of the same lexeme. To save space and time, a common compiler practice is to store lexemes in a `string table`. 

There is an issue in deciding how to handle the special identifiers for the basic classes (`Object`, `Int`, `Bool`, `String`), `SELF_TYPE`, and `self`. However, this issue doesn’t actually come up until later phases of the compiler—the scanner should treat the special identifiers exactly like any other identifier.

Do not test whether integer literals fit within the representation specified in the Cool manual—simply create a Symbol with the entire literal’s text as its contents, regardless of its length.

### Strings

- Your scanner should convert escape characters in string constants to their correct values. e.x.:
`"ab\ncd"` => `ab\ncd` where `\n` represents the literal ASCII character for newline.
- Following specification on page 15 of the Cool manual, you must return an error for a string containing the literal null character. However, the sequence of two characters `\0` is allowed but should be converted to the one character `0`.

### Other Notes

- Your scanner should maintain the variable `curr_lineno` that indicates which line in the source text is currently being scanned. This feature will aid the parser in printing useful error messages.
- You should ignore the token `LET_STMT`. It is used only by the **parser** (PA3). Finally, note that if the lexical specification is incomplete (some input has no regular expression that matches), then the scanners generated by both flex and jlex do undesirable things.
- If some text can't match, they would be ouput to stdout.

### Notes for the C++ Version of the Assignment

- Each call on the scanner **returns the next token and lexeme** from the input. The value returned by the function `cool_yylex` is an integer code representing the syntactic category (e.g., integer literal, semicolon, if keyword, etc.). The codes for all tokens are defined in the file `cool-parse.h`. The second component, the **semantic value** or **lexeme**, is placed in the global union `cool_yylval`, which is of type `YYSTYPE`. The type `YYSTYPE` is also defined in `cool-parse.h`. The tokens for **single character symbols** (e.g., “;” and “,”) are represented just by the **integer (ASCII) value** of the character itself. All of the single character tokens are listed in the grammar for Cool in the Cool manual.
- For class identifiers, object identifiers, integers, and strings, the semantic value should be a **Symbol** stored in the field `cool_yylval.symbol`. For boolean constants, the semantic value is stored in the field `cool_yylval.boolean`. Except for errors (see below), the lexemes for the other tokens do not carry any interesting information.
- We provide you with a **string table implementation**, which is discussed in detail in *A Tour of the Cool Support Code* and in documentation in the code. For the moment, you only need to know that the type of string table entries is **Symbol**.
- When a lexical error is encountered, the routine `cool_yylex` should return the token `ERROR`. The semantic value is the string representing the error message, which is stored in the field cool `yylval.error_msg` (note that this field is an ordinary string, not a symbol). See the previous section for information on what to put in error messages.
